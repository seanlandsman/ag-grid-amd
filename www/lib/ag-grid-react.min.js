define(['exports', 'prop-types', 'react', 'react-dom', 'ag-grid-community', 'react-dom/server'], function (exports, PropTypes, React, ReactDOM, AgGrid, server) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    var AgGridColumn = /** @class */ (function (_super) {
        __extends(AgGridColumn, _super);
        function AgGridColumn(props, state) {
            var _this = _super.call(this, props, state) || this;
            _this.props = props;
            _this.state = state;
            return _this;
        }
        AgGridColumn.prototype.render = function () {
            return null;
        };
        AgGridColumn.mapChildColumnDefs = function (columnProps) {
            return React.Children.map(columnProps.children, function (child) {
                return AgGridColumn.toColDef(child.props);
            });
        };
        AgGridColumn.toColDef = function (columnProps) {
            var colDef = AgGridColumn.createColDefFromGridColumn(columnProps);
            if (AgGridColumn.hasChildColumns(columnProps)) {
                colDef["children"] = AgGridColumn.getChildColDefs(columnProps.children);
            }
            return colDef;
        };
        AgGridColumn.hasChildColumns = function (columnProps) {
            return React.Children.count(columnProps.children) > 0;
        };
        AgGridColumn.getChildColDefs = function (columnChildren) {
            return React.Children.map(columnChildren, function (child) {
                return AgGridColumn.createColDefFromGridColumn(child.props);
            });
        };
        AgGridColumn.createColDefFromGridColumn = function (columnProps) {
            var colDef = {};
            AgGridColumn.assign(colDef, columnProps);
            delete colDef.children;
            return colDef;
        };
        AgGridColumn.assign = function (colDef, from) {
            // effectively Object.assign - here for IE compatibility
            return [from].reduce(function (r, o) {
                Object.keys(o).forEach(function (k) {
                    r[k] = o[k];
                });
                return r;
            }, colDef);
        };
        return AgGridColumn;
    }(React.Component));
    addProperties(AgGrid.ColDefUtil.BOOLEAN_PROPERTIES, PropTypes.bool);
    addProperties(AgGrid.ColDefUtil.STRING_PROPERTIES, PropTypes.string);
    addProperties(AgGrid.ColDefUtil.OBJECT_PROPERTIES, PropTypes.object);
    addProperties(AgGrid.ColDefUtil.ARRAY_PROPERTIES, PropTypes.array);
    addProperties(AgGrid.ColDefUtil.NUMBER_PROPERTIES, PropTypes.number);
    addProperties(AgGrid.ColDefUtil.FUNCTION_PROPERTIES, PropTypes.func);
    function addProperties(listOfProps, propType) {
        listOfProps.forEach(function (propKey) {
            AgGridColumn[propKey] = propType;
        });
    }

    var BaseReactComponent = /** @class */ (function () {
        function BaseReactComponent() {
        }
        BaseReactComponent.prototype.hasMethod = function (name) {
            var frameworkComponentInstance = this.getFrameworkComponentInstance();
            if (frameworkComponentInstance == null) {
                return false;
            }
            return frameworkComponentInstance[name] != null;
        };
        BaseReactComponent.prototype.callMethod = function (name, args) {
            var _this = this;
            var frameworkComponentInstance = this.getFrameworkComponentInstance();
            // this should never happen now that AgGridReact.waitForInstance is in use
            if (frameworkComponentInstance == null) {
                window.setTimeout(function () { return _this.callMethod(name, args); }, 100);
            }
            else {
                var method = this.getFrameworkComponentInstance()[name];
                if (method == null)
                    return;
                return method.apply(frameworkComponentInstance, args);
            }
        };
        BaseReactComponent.prototype.addMethod = function (name, callback) {
            this[name] = callback;
        };
        return BaseReactComponent;
    }());

    // effectively Object.assign - here for IE compatibility
    var assignProperties = function (to, from) {
        var styleKeys = Object.keys(from);
        styleKeys.forEach(function (key) {
            to[key] = from[key];
        });
    };

    var counter = 0;
    function generateNewKey() {
        return "agPortalKey_" + ++counter;
    }

    var ReactComponent = /** @class */ (function (_super) {
        __extends(ReactComponent, _super);
        function ReactComponent(reactComponent, parentComponent, componentType) {
            var _this = _super.call(this) || this;
            _this.portal = null;
            _this.componentWrappingElement = 'div';
            _this.staticMarkup = null;
            _this.reactComponent = reactComponent;
            _this.componentType = componentType;
            _this.parentComponent = parentComponent;
            _this.statelessComponent = ReactComponent.isStateless(_this.reactComponent);
            return _this;
        }
        ReactComponent.prototype.getFrameworkComponentInstance = function () {
            return this.componentInstance;
        };
        ReactComponent.prototype.isStatelessComponent = function () {
            return this.statelessComponent;
        };
        ReactComponent.prototype.getReactComponentName = function () {
            return this.reactComponent.name;
        };
        ReactComponent.prototype.init = function (params) {
            var _this = this;
            this.eParentElement = this.createParentElement(params);
            this.renderStaticMarkup(params);
            return new AgGrid.Promise(function (resolve) {
                _this.createReactComponent(params, resolve);
            });
        };
        ReactComponent.prototype.getGui = function () {
            return this.eParentElement;
        };
        ReactComponent.prototype.destroy = function () {
            return this.parentComponent.destroyPortal(this.portal);
        };
        ReactComponent.prototype.createReactComponent = function (params, resolve) {
            var _this = this;
            if (!this.statelessComponent) {
                // grab hold of the actual instance created
                params.ref = function (element) {
                    _this.componentInstance = element;
                    _this.addParentContainerStyleAndClasses();
                    // regular components (ie not functional)
                    _this.removeStaticMarkup();
                };
            }
            var reactComponent = React.createElement(this.reactComponent, params);
            var portal = ReactDOM.createPortal(reactComponent, this.eParentElement, generateNewKey() // fixed deltaRowModeRefreshCompRenderer
            );
            this.portal = portal;
            this.parentComponent.mountReactPortal(portal, this, function (value) {
                resolve(value);
                // functional/stateless components have a slightly different lifecycle (no refs) so we'll clean them up
                // here
                if (_this.statelessComponent) {
                    setTimeout(function () {
                        _this.removeStaticMarkup();
                    });
                }
            });
        };
        ReactComponent.prototype.addParentContainerStyleAndClasses = function () {
            var _this = this;
            if (!this.componentInstance) {
                return;
            }
            if (this.componentInstance.getReactContainerStyle && this.componentInstance.getReactContainerStyle()) {
                assignProperties(this.eParentElement.style, this.componentInstance.getReactContainerStyle());
            }
            if (this.componentInstance.getReactContainerClasses && this.componentInstance.getReactContainerClasses()) {
                var parentContainerClasses = this.componentInstance.getReactContainerClasses();
                parentContainerClasses.forEach(function (className) { return AgGrid._.addCssClass(_this.eParentElement, className); });
            }
        };
        ReactComponent.prototype.createParentElement = function (params) {
            var eParentElement = document.createElement(this.parentComponent.props.componentWrappingElement || 'div');
            AgGrid._.addCssClass(eParentElement, 'ag-react-container');
            // DEPRECATED - use componentInstance.getReactContainerStyle or componentInstance.getReactContainerClasses instead
            // so user can have access to the react container, to add css class or style
            params.reactContainer = eParentElement;
            return eParentElement;
        };
        ReactComponent.prototype.statelessComponentRendered = function () {
            // fixed fragmentsFuncRendererCreateDestroy funcRendererWithNan (changeDetectionService too for NaN)
            return this.eParentElement.childElementCount > 0 || this.eParentElement.childNodes.length > 0;
        };
        ReactComponent.hasSymbol = function () {
            return typeof Symbol === 'function' && Symbol.for;
        };
        ReactComponent.isStateless = function (Component) {
            return (typeof Component === 'function' && !(Component.prototype && Component.prototype.isReactComponent))
                || (typeof Component === 'object' && Component.$$typeof === ReactComponent.REACT_MEMO_TYPE);
        };
        ReactComponent.prototype.isNullRender = function () {
            return this.staticMarkup === "";
        };
        /*
         * Attempt to render the component as static markup if possible
         * What this does is eliminate any visible flicker for the user in the scenario where a component is destroyed and
         * recreated with exactly the same data (ie with force refresh)
         * Note: Some use cases will throw an error (ie when using Context) so if an error occurs just ignore it any move on
         */
        ReactComponent.prototype.renderStaticMarkup = function (params) {
            if (this.parentComponent.isDisableStaticMarkup() || !this.componentType.isCellRenderer()) {
                return;
            }
            var originalConsoleError = console.error;
            var reactComponent = React.createElement(this.reactComponent, params);
            try {
                // if a user is using anything that uses useLayoutEffect (like material ui) then
                // Warning: useLayoutEffect does nothing on the s   erver will be throw and we can't do anything to stop it
                // this is just a warning and has no effect on anything so just suppress it for this single operation
                var originalConsoleError_1 = console.error;
                console.error = function () { };
                var staticMarkup = server.renderToStaticMarkup(reactComponent);
                console.error = originalConsoleError_1;
                // if the render method returns null the result will be an empty string
                if (staticMarkup === "") {
                    this.staticMarkup = staticMarkup;
                }
                else {
                    if (staticMarkup) {
                        // we wrap the content as if there is "trailing" text etc it's not easy to safely remove
                        // the same is true for memoized renderers, renderers that that return simple strings or NaN etc
                        this.staticMarkup = document.createElement('span');
                        this.staticMarkup.innerHTML = staticMarkup;
                        this.eParentElement.appendChild(this.staticMarkup);
                    }
                }
            }
            catch (e) {
                // we tried - this can happen with certain (rare) edge cases
            }
            finally {
                console.error = originalConsoleError;
            }
        };
        ReactComponent.prototype.removeStaticMarkup = function () {
            if (this.parentComponent.isDisableStaticMarkup() || !this.componentType.isCellRenderer()) {
                return;
            }
            if (this.staticMarkup) {
                if (this.staticMarkup.remove) {
                    // everyone else in the world
                    this.staticMarkup.remove();
                    this.staticMarkup = null;
                }
                else if (this.eParentElement.removeChild) {
                    // ie11...
                    this.eParentElement.removeChild(this.staticMarkup);
                    this.staticMarkup = null;
                }
            }
        };
        ReactComponent.prototype.rendered = function () {
            return this.isNullRender() ||
                this.staticMarkup ||
                (this.isStatelessComponent() && this.statelessComponentRendered()) ||
                (!this.isStatelessComponent() && this.getFrameworkComponentInstance());
        };
        ReactComponent.REACT_MEMO_TYPE = ReactComponent.hasSymbol() ? Symbol.for('react.memo') : 0xead3;
        return ReactComponent;
    }(BaseReactComponent));

    var ChangeDetectionStrategyType;
    (function (ChangeDetectionStrategyType) {
        ChangeDetectionStrategyType["IdentityCheck"] = "IdentityCheck";
        ChangeDetectionStrategyType["DeepValueCheck"] = "DeepValueCheck";
        ChangeDetectionStrategyType["NoCheck"] = "NoCheck";
    })(ChangeDetectionStrategyType || (ChangeDetectionStrategyType = {}));
    var ChangeDetectionService = /** @class */ (function () {
        function ChangeDetectionService() {
            var _a;
            this.strategyMap = (_a = {},
                _a[ChangeDetectionStrategyType.DeepValueCheck] = new DeepValueStrategy(),
                _a[ChangeDetectionStrategyType.IdentityCheck] = new SimpleFunctionalStrategy(function (a, b) { return a === b; }),
                _a[ChangeDetectionStrategyType.NoCheck] = new SimpleFunctionalStrategy(function (a, b) { return true; }),
                _a);
        }
        ChangeDetectionService.prototype.getStrategy = function (changeDetectionStrategy) {
            return this.strategyMap[changeDetectionStrategy];
        };
        return ChangeDetectionService;
    }());
    var SimpleFunctionalStrategy = /** @class */ (function () {
        function SimpleFunctionalStrategy(strategy) {
            this.strategy = strategy;
        }
        SimpleFunctionalStrategy.prototype.areEqual = function (a, b) {
            return this.strategy(a, b);
        };
        return SimpleFunctionalStrategy;
    }());
    var DeepValueStrategy = /** @class */ (function () {
        function DeepValueStrategy() {
        }
        DeepValueStrategy.prototype.areEqual = function (a, b) {
            return DeepValueStrategy.areEquivalent(DeepValueStrategy.copy(a), DeepValueStrategy.copy(b));
        };
        /*
         * deeper object comparison - taken from https://stackoverflow.com/questions/1068834/object-comparison-in-javascript
         */
        DeepValueStrategy.unwrapStringOrNumber = function (obj) {
            return obj instanceof Number || obj instanceof String ? obj.valueOf() : obj;
        };
        // sigh, here for ie compatibility
        DeepValueStrategy.copy = function (value) {
            if (!value) {
                return value;
            }
            if (Array.isArray(value)) {
                // shallow copy the array - this will typically be either rowData or columnDefs
                var arrayCopy = [];
                for (var i = 0; i < value.length; i++) {
                    arrayCopy.push(this.copy(value[i]));
                }
                return arrayCopy;
            }
            // for anything without keys (boolean, string etc).
            // Object.keys - chrome will swallow them, IE will fail (correctly, imho)
            if (typeof value !== "object") {
                return value;
            }
            return [{}, value].reduce(function (r, o) {
                Object.keys(o).forEach(function (k) {
                    r[k] = o[k];
                });
                return r;
            }, {});
        };
        DeepValueStrategy.isNaN = function (value) {
            if (Number.isNaN) {
                return Number.isNaN(value);
            }
            // for ie11...
            return typeof (value) === 'number' && isNaN(value);
        };
        /*
         * slightly modified, but taken from https://stackoverflow.com/questions/1068834/object-comparison-in-javascript
         *
         * What we're trying to do here is determine if the property being checked has changed in _value_, not just in reference
         *
         * For eg, if a user updates the columnDefs via property binding, but the actual columns defs are the same before and
         * after, then we don't want the grid to re-render
         */
        DeepValueStrategy.areEquivalent = function (a, b) {
            a = DeepValueStrategy.unwrapStringOrNumber(a);
            b = DeepValueStrategy.unwrapStringOrNumber(b);
            if (a === b)
                return true; //e.g. a and b both null
            if (a === null || b === null || typeof a !== typeof b)
                return false;
            if (DeepValueStrategy.isNaN(a) && DeepValueStrategy.isNaN(b)) {
                return true;
            }
            if (a instanceof Date) {
                return b instanceof Date && a.valueOf() === b.valueOf();
            }
            if (typeof a === "function") {
                return a.toString() === b.toString();
            }
            if (typeof a !== "object") {
                return a == b; //for boolean, number, string, function, xml
            }
            var newA = a.areEquivPropertyTracking === undefined, newB = b.areEquivPropertyTracking === undefined;
            try {
                var prop = void 0;
                if (newA) {
                    a.areEquivPropertyTracking = [];
                }
                else if (a.areEquivPropertyTracking.some(function (other) {
                    return other === b;
                }))
                    return true;
                if (newB) {
                    b.areEquivPropertyTracking = [];
                }
                else if (b.areEquivPropertyTracking.some(function (other) { return other === a; })) {
                    return true;
                }
                a.areEquivPropertyTracking.push(b);
                b.areEquivPropertyTracking.push(a);
                var tmp = {};
                for (prop in a)
                    if (prop != "areEquivPropertyTracking") {
                        tmp[prop] = null;
                    }
                for (prop in b)
                    if (prop != "areEquivPropertyTracking") {
                        tmp[prop] = null;
                    }
                for (prop in tmp) {
                    if (!this.areEquivalent(a[prop], b[prop])) {
                        return false;
                    }
                }
                return true;
            }
            finally {
                if (newA)
                    delete a.areEquivPropertyTracking;
                if (newB)
                    delete b.areEquivPropertyTracking;
            }
        };
        return DeepValueStrategy;
    }());

    var AgGridReact = /** @class */ (function (_super) {
        __extends(AgGridReact, _super);
        function AgGridReact(props, state) {
            var _this = _super.call(this, props, state) || this;
            _this.props = props;
            _this.state = state;
            _this.changeDetectionService = new ChangeDetectionService();
            _this.api = null;
            _this.portals = [];
            _this.hasPendingPortalUpdate = false;
            _this.destroyed = false;
            return _this;
        }
        AgGridReact.prototype.render = function () {
            var _this = this;
            return React.createElement("div", {
                style: this.createStyleForDiv(),
                ref: function (e) {
                    _this.eGridDiv = e;
                }
            }, this.portals);
        };
        AgGridReact.prototype.createStyleForDiv = function () {
            var style = { height: "100%" };
            // allow user to override styles
            var containerStyle = this.props.containerStyle;
            if (containerStyle) {
                Object.keys(containerStyle).forEach(function (key) {
                    style[key] = containerStyle[key];
                });
            }
            return style;
        };
        AgGridReact.prototype.componentDidMount = function () {
            var modules = this.props.modules || [];
            var gridParams = {
                providedBeanInstances: {
                    agGridReact: this,
                    frameworkComponentWrapper: new ReactFrameworkComponentWrapper(this)
                },
                modules: modules
            };
            var gridOptions = this.props.gridOptions || {};
            if (AgGridColumn.hasChildColumns(this.props)) {
                gridOptions.columnDefs = AgGridColumn.mapChildColumnDefs(this.props);
            }
            this.gridOptions = AgGrid.ComponentUtil.copyAttributesToGridOptions(gridOptions, this.props);
            // don't need the return value
            new AgGrid.Grid(this.eGridDiv, this.gridOptions, gridParams);
            this.api = this.gridOptions.api;
            this.columnApi = this.gridOptions.columnApi;
        };
        AgGridReact.prototype.waitForInstance = function (reactComponent, resolve, runningTime) {
            var _this = this;
            if (runningTime === void 0) { runningTime = 0; }
            // if the grid has been destroyed in the meantime just resolve
            if (this.destroyed) {
                resolve(null);
                return;
            }
            if (reactComponent.rendered()) {
                resolve(null);
            }
            else {
                if (runningTime >= AgGridReact.MAX_COMPONENT_CREATION_TIME) {
                    console.error("ag-Grid: React Component '" + reactComponent.getReactComponentName() + "' not created within " + AgGridReact.MAX_COMPONENT_CREATION_TIME + "ms");
                    return;
                }
                window.setTimeout(function () { return _this.waitForInstance(reactComponent, resolve, runningTime + 5); }, 5);
            }
        };
        /**
         * Mounts a react portal for components registered under the componentFramework.
         * We do this because we want all portals to be in the same tree - in order to get
         * Context to work properly.
         */
        AgGridReact.prototype.mountReactPortal = function (portal, reactComponent, resolve) {
            this.portals = __spreadArrays(this.portals, [portal]);
            this.batchUpdate(this.waitForInstance(reactComponent, resolve));
        };
        AgGridReact.prototype.batchUpdate = function (callback) {
            var _this = this;
            if (this.hasPendingPortalUpdate) {
                return callback && callback();
            }
            setTimeout(function () {
                if (_this.api) { // destroyed?
                    _this.forceUpdate(function () {
                        callback && callback();
                        _this.hasPendingPortalUpdate = false;
                    });
                }
            });
            this.hasPendingPortalUpdate = true;
        };
        AgGridReact.prototype.destroyPortal = function (portal) {
            this.portals = this.portals.filter(function (curPortal) { return curPortal !== portal; });
            this.batchUpdate();
        };
        AgGridReact.prototype.getStrategyTypeForProp = function (propKey) {
            if (propKey === 'rowData') {
                // for row data we either return the supplied strategy, or:
                // if deltaRowDataMode we default to IdentityChecks,
                // if not we default to DeepValueChecks (with the rest of the properties)
                if (!!this.props.rowDataChangeDetectionStrategy) {
                    return this.props.rowDataChangeDetectionStrategy;
                }
                else if (this.props['deltaRowDataMode']) {
                    return ChangeDetectionStrategyType.IdentityCheck;
                }
            }
            // all non row data properties will default to DeepValueCheck
            return ChangeDetectionStrategyType.DeepValueCheck;
        };
        AgGridReact.prototype.shouldComponentUpdate = function (nextProps) {
            this.processPropsChanges(this.props, nextProps);
            // we want full control of the dom, as ag-Grid doesn't use React internally,
            // so for performance reasons we tell React we don't need render called after
            // property changes.
            return false;
        };
        AgGridReact.prototype.componentDidUpdate = function (prevProps) {
            this.processPropsChanges(prevProps, this.props);
        };
        AgGridReact.prototype.processPropsChanges = function (prevProps, nextProps) {
            var changes = {};
            this.extractGridPropertyChanges(prevProps, nextProps, changes);
            this.extractDeclarativeColDefChanges(nextProps, changes);
            if (Object.keys(changes).length > 0) {
                AgGrid.ComponentUtil.processOnChange(changes, this.gridOptions, this.api, this.columnApi);
            }
        };
        AgGridReact.prototype.extractDeclarativeColDefChanges = function (nextProps, changes) {
            var debugLogging = !!nextProps.debug;
            if (AgGridColumn.hasChildColumns(nextProps)) {
                var detectionStrategy = this.changeDetectionService.getStrategy(ChangeDetectionStrategyType.DeepValueCheck);
                var currentColDefs = this.gridOptions.columnDefs;
                var newColDefs = AgGridColumn.mapChildColumnDefs(nextProps);
                if (!detectionStrategy.areEqual(currentColDefs, newColDefs)) {
                    if (debugLogging) {
                        console.log("agGridReact: colDefs definitions changed");
                    }
                    changes['columnDefs'] =
                        {
                            previousValue: this.gridOptions.columnDefs,
                            currentValue: AgGridColumn.mapChildColumnDefs(nextProps)
                        };
                }
            }
        };
        AgGridReact.prototype.extractGridPropertyChanges = function (prevProps, nextProps, changes) {
            var _this = this;
            var debugLogging = !!nextProps.debug;
            var changedKeys = Object.keys(nextProps);
            changedKeys.forEach(function (propKey) {
                if (AgGrid.ComponentUtil.ALL_PROPERTIES.indexOf(propKey) !== -1) {
                    var changeDetectionStrategy = _this.changeDetectionService.getStrategy(_this.getStrategyTypeForProp(propKey));
                    if (!changeDetectionStrategy.areEqual(prevProps[propKey], nextProps[propKey])) {
                        if (debugLogging) {
                            console.log("agGridReact: [" + propKey + "] property changed");
                        }
                        changes[propKey] = {
                            previousValue: prevProps[propKey],
                            currentValue: nextProps[propKey]
                        };
                    }
                }
            });
            AgGrid.ComponentUtil.getEventCallbacks().forEach(function (funcName) {
                if (_this.props[funcName] !== nextProps[funcName]) {
                    if (debugLogging) {
                        console.log("agGridReact: [" + funcName + "] event callback changed");
                    }
                    changes[funcName] = {
                        previousValue: prevProps[funcName],
                        currentValue: nextProps[funcName]
                    };
                }
            });
        };
        AgGridReact.prototype.componentWillUnmount = function () {
            if (this.api) {
                this.api.destroy();
                this.api = null;
            }
            this.destroyed = true;
        };
        AgGridReact.prototype.isDisableStaticMarkup = function () {
            return !!this.props.disableStaticMarkup;
        };
        AgGridReact.MAX_COMPONENT_CREATION_TIME = 1000; // a second should be more than enough to instantiate a component
        return AgGridReact;
    }(React.Component));
    AgGridReact.propTypes = {
        gridOptions: PropTypes.object
    };
    addProperties$1(AgGrid.ComponentUtil.getEventCallbacks(), PropTypes.func);
    addProperties$1(AgGrid.ComponentUtil.BOOLEAN_PROPERTIES, PropTypes.bool);
    addProperties$1(AgGrid.ComponentUtil.STRING_PROPERTIES, PropTypes.string);
    addProperties$1(AgGrid.ComponentUtil.OBJECT_PROPERTIES, PropTypes.object);
    addProperties$1(AgGrid.ComponentUtil.ARRAY_PROPERTIES, PropTypes.array);
    addProperties$1(AgGrid.ComponentUtil.NUMBER_PROPERTIES, PropTypes.number);
    addProperties$1(AgGrid.ComponentUtil.FUNCTION_PROPERTIES, PropTypes.func);
    function addProperties$1(listOfProps, propType) {
        listOfProps.forEach(function (propKey) {
            AgGridReact[propKey] = propType;
        });
    }
    var ReactFrameworkComponentWrapper = /** @class */ (function (_super) {
        __extends(ReactFrameworkComponentWrapper, _super);
        function ReactFrameworkComponentWrapper(agGridReact) {
            var _this = _super.call(this) || this;
            _this.agGridReact = agGridReact;
            return _this;
        }
        ReactFrameworkComponentWrapper.prototype.createWrapper = function (UserReactComponent, componentType) {
            return new ReactComponent(UserReactComponent, this.agGridReact, componentType);
        };
        return ReactFrameworkComponentWrapper;
    }(AgGrid.BaseComponentWrapper));

    // https://github.com/rollup/rollup-plugin-typescript/issues/109
    // export {ICellEditorReactComp} from './interfaces';
    // export {AgReactFrameworkComponent}  from './interfaces';
    // export {IHeaderGroupReactComp }  from './interfaces';
    // export {IHeaderReactComp }  from './interfaces';
    // export {IDateReactComp }  from './interfaces';
    // export {IFilterReactComp }  from './interfaces';
    // export {ICellRendererReactComp }  from './interfaces';
    // export {ILoadingCellRendererReactComp }  from './interfaces';
    // export {ILoadingOverlayReactComp }  from './interfaces';
    // export {INoRowsOverlayReactComp }  from './interfaces';
    // export {IStatusPanelReactComp }  from './interfaces';
    // export {IToolPanelReactComp }  from './interfaces';

    exports.AgGridReact = AgGridReact;
    exports.AgGridColumn = AgGridColumn;

    Object.defineProperty(exports, '__esModule', { value: true });

});
